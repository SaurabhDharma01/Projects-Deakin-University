x = 1
y <- 2
print("Hello World")
run data()
data()
?women
x = 1
y <- 2
print("Hello World")
data()
install.packages("readr")
liabrary(readr)
library(readr)
install.packages("dplyr")
library(dplyr)
install.packages("ggplot2")
library(ggplot2)
array(0, c(3,4))
array(c(4,5,6), 12)
array(c(1,2,3), 10)
array(c(1,2,3), 10)
a = array(0,20)
a
a[5] = 1
a
a[c(3,7,11)] = c(2,6,1)
a
a[17:20] = c(1,2,1,4)
a
4:8
array(c(0,1,2,3,4), c(3,4))
array(c(0,1,2,3), c(3,4))
array(c(0,1,2), c(3,4))
array(c(0,1,2,3,4), c(3,4))
array(6,5)
cbind(c(1,2,3,7,9), c(21, 2, 1, 5, 6))
cbind(c(1,2,3,7,9), c(21, 2, 1, 5))
cbind(c(1,2,3,7,9), c(1,9,7,2,1), array(6,5))
rbind(c(3,6,1,92), c(10,3,1))
rbind(c(3,6,1,92), c(3,2,1,8))
rbind(c(3,6,1,92), c(4,1,12,1,2))
sumArray = function(arrayOfNumbers) {
result = 0
for(i in c(1:length(arrayOfNumbers))) {
result = result + arrayOfNumbers[i]
}
result
}
b = array(1,2,3,4,5,6)
sumArray(b)
sumArray(c(b))
b = array(1,2,3,4,5,6)
array(0, c(3,4))
array(c(4,5,6), 12)
array(c(1,2,3), 10)
a = array(0,20)
a
a[5] = 1
a
a[c(3,7,11)] = c(2,6,1)
a
a[17:20] = c(1,2,1,4)
a
4:8
array(c(0,1,2,3,4), c(3,4))
array(6,5)
cbind(c(1,2,3,7,9), c(1,9,7,2,1), array(6,5))
rbind(c(3,6,1,92), c(10,3,1))
rbind(c(3,6,1,92), c(3,2,1,8))
rbind(c(3,6,1,92), c(4,1,12,1,2))
sumArray = function(arrayOfNumbers) {
result = 0
for(i in c(1:length(arrayOfNumbers))) {
result = result + arrayOfNumbers[i]
}
result
}
b = array(1,2,3,4,5,6)
b = array(c(1,2,3,4,5,6))
sumArray(c(b))
d <- array(c(1,2,3,NA,5,6,7))
sumArray(d)
sumArray(b)
d <- array(c(1,2,3,4,5,6,7))
sumArray(d)
sumArray(c(1,2,3,4))
sumArray(c(9,4,"t",5))
sumArray(c("not","a","number"))
sumArray = function(arrayOfNumbers) {
result = 0
if(typeof(arrayOfNumbers)=="double") {
for(i in c(1:length(arrayOfNumbers))) {
result = result + arrayOfNumbers[i]
}
result
} else
print("Warning: There is a non-numeric element in your array.")
}
sumArray(c(b))
sumArray(d)
sumArray(c(1,2,3,4))
sumArray(c(9,4,"t",5))
sumArray(c("not","a","number"))
mean(c(9,8,2,3))
table(a)
a
print(paste("Mode:", mode_result))
calculate_mode <- function(numbers) {
table_numbers <- table(numbers)
mode_frequency <- max(table_numbers)
# If there is no repeated value, return NA
if (mode_frequency == 1) {
return(NA)
}
# Extract values with the highest frequency (there could be multiple modes)
modes <- as.numeric(names(table_numbers[table_numbers == mode_frequency]))
return(modes)
}
# Example usage:
numbers <- c(4, 7, 1, 9, 2, 5, 8, 4, 2, 9)
mode_result <- calculate_mode(numbers)
print(paste("Mode:", mode_result))
calculate_mode(a)
calculate_mode <- function(numbers) {
table_numbers <- table(numbers)
mode_frequency <- max(table_numbers)
# If there is no repeated value, return NA
if (mode_frequency == 1) {
return(NA)
}
# Extract values with the highest frequency (there could be multiple modes)
else{
modes <- as.numeric(names(table_numbers[table_numbers == mode_frequency]))
return(modes)
}
}
# Example usage:
numbers <- c(4, 7, 1, 9, 2, 5, 8, 4, 2, 9)
mode_result <- calculate_mode(numbers)
print(paste("Mode:", mode_result))
calculate_mode(a)
max(a)
max(table(a))
max(names(table(a)))
max(table(a))
max(a)
max(table(a))
max(a)
max(table(a))
calculate_mode(a)
table(a)
names(max(table(a)))
names(table(a)[table(a) == max(table(a))])
HM = function(x) {
if(prod(x)==0) {
return (0)
} else {
length(x)/sum(1/x)
}
}
HM(5,4,6)
HM(5)
HM(a)
HM(b)
HMM = function(x) {
non_zero_values = x[x != 0]
length(non_zero_values) / sum(1 / non_zero_values)
}
HMM(a)
PM = function(x, p) {
if (p ==0) {
prod(x)^{1/length(x)}
} else {
mean(x^p)^{1/p}
}
}
?runif
sd(c(1,4,7,12))
density = 10  # density of shading lines
# Create a line plot with probabilities
plot(c(1:6),  # x-axis values (1 to 6)
array(1/5, 6),  # y-axis values (probability 1/5 for each value from 1 to 6)
type = "l",  # type of plot ("l" for line plot)
xlim = c(0, 7),  # x-axis limits (from 0 to 7)
ylim = c(0, 1),  # y-axis limits (from 0 to 1)
xlab = "Value",  # x-axis label
ylab = "Probability",  # y-axis label
main = "Probability of Picking a Real Number Between 1 and 6"  # main plot title
)
density = 10  # density of shading lines
# Add a shaded polygon to represent the probability distribution
c(0, 0.2, 0.2, 0),  # y-coordinates of the polygon vertices
density = 10  # density of shading lines
polygon(c(1, 1, 6, 6), c(0, 0.2, 0.2, 0), angle = 30, density = 10)
normalData = rnorm(1000,400,5)
hist(normalData)
normalData = rnorm(1000,400,20)
hist(normalData)
normalData = rnorm(1000,400,30)
hist(normalData)
normalData = rnorm(1000,400,40)
hist(normalData)
normalData = rnorm(1000,400,20)
hist(normalData)
standardisedData = (normalData - 400)/20
hist(standardisedData)
sumArray = function(arrayOfNumbers) {
result = 0
if(typeof(arrayOfNumbers)=="double") {
for(i in c(1:length(arrayOfNumbers))) {
result = result + arrayOfNumbers[i]
}
result
} else
print("Warning: There is a non-numeric element in your array.")
}
aa = c(1,2,3,4)
bb = c(9,4,"t",5)
cc = c("not","a","number")
sumArray(aa)
sumArray(bb)
sumArray(cc)
bb = c(9,4,4,5)
sumArray(bb)
# Set the working directory to a specific path
setwd("C:/Users/Arun/Downloads/Deakin/Real World Analytics/Preparation/Week 1")
# Get the current working directory
getwd()
data = read.csv(ebola.csv)
data = read.csv("ebola.csv")
View(data)
ebla_data = read.csv("ebola.csv")
View(data)
View(data)
# Set the working directory to a specific path
setwd("C:/Users/Arun/Downloads/Deakin/Real World Analytics/Preparation/Week 1")
# Set the working directory to a specific path
setwd("C:/Users/Arun/Downloads/Deakin/Real World Analytics/Preparation/Week 1")
# Get the current working directory
getwd()
ebla_data = read.csv("ebola.csv")
# Set the working directory to a specific path
setwd("C:/Users/Arun/Downloads/Deakin/Real World Analytics/Preparation/Week 1")
# Get the current working directory
getwd()
ebla_data = read.csv("ebola.csv")
View(ebla_data)
volley_data = read.table("valley.txt")
volley_data = read.table("volley.txt")
View(volley_data)
hist(volley_data[,2])
# Create a vector of colors (one color per bar)
bar_colors <- c("skyblue", "salmon", "lightgreen", "gold", "purple")
# Plot histogram with custom colors
hist(volley_data[, 2], col = bar_colors, main = "Histogram", xlab = "Values", ylab = "Frequency")
# Create a vector of colors (one color per bar)
bar_colors <- c("skyblue", "salmon", "lightgreen", "gold", "purple1")
# Plot histogram with custom colors
hist(volley_data[, 2], col = bar_colors, main = "Histogram", xlab = "Values", ylab = "Frequency")
# Plot histogram with filled colors
hist(volley_data[, 2], col = "skyblue", main = "Histogram", xlab = "Values", ylab = "Frequency")
library(lpSolve)
# Coefficients of the objective function
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(-3, -1, -1, -1, 0, 0, 0, -1), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(-10, -5, -3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Coefficients of the objective function
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(-3, -1, -1, -1, 0, -1), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(-10, -5, -3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(lpSolve)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(-3, -1, -1, -1, 0, 0, -1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(-10, -5, -3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
# Install and load the lpSolve package
install.packages("lpSolve")
# Install and load the lpSolve package
library(lpSolve)
# Install and load the lpSolve package
library(lpSolve)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(-3, -1, -1, -1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(-10, -5, -3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(lpSolve)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(-3, -1, -1, -1, 0, 0, -1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(-10, -5, -3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(lpSolve)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(3, 1, 1, 1, 0, 0, 1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(10, 5, 3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(ROI)
# Install and load the ROI package
install.packages("ROI")
library(ROI)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(3, 1, 1, 1, 0, 0, 1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(10, 5, 3)
# Install and load the ROI package
# install.packages("ROI")
library(ROI)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(3, 1, 1, 1, 0, 0, 1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(10, 5, 3)
# Define the linear programming problem
lp <- ROI::LPOpt(obj = obj, const = mat, dir = ">=", rhs = rhs)
# Solve the linear programming problem
result <- ROI::ROI_solve(lp)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(lpSolve)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(3, 1, 1, 1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(10, 5, 3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(ggplot2)
# Constraints
x <- seq(0, 5, by = 0.1)
y1 <- 10 - 3 * x
y2 <- 5 - x
y3 <- rep(0, length(x))
y4 <- rep(0, length(x))
df <- data.frame(x, y1, y2, y3, y4)
# Plot
ggplot(df, aes(x, y1)) +
geom_line() +
geom_line(aes(x, y2), color = "red") +
geom_line(aes(x, y3), linetype = "dashed") +
geom_line(aes(x, y4), linetype = "dashed") +
geom_area(fill = "gray", alpha = 0.3, xlim = c(3, 5)) +
xlim(0, 5) +
ylim(0, 10) +
labs(title = "Graphical Representation of Constraints",
x = "x",
y = "y") +
theme_minimal()
library(ggplot2)
# Constraints
x <- seq(0, 5, by = 0.1)
y1 <- 10 - 3 * x
y2 <- 5 - x
y3 <- rep(0, length(x))
y4 <- rep(0, length(x))
df <- data.frame(x, y1, y2, y3, y4)
# Plot
ggplot(df, aes(x, y1)) +
geom_line() +
geom_line(aes(x, y2), color = "red") +
geom_ribbon(data = df, aes(x = x, ymin = pmin(y1, y2), ymax = pmax(y1, y2)), fill = "gray", alpha = 0.3) +
geom_line(aes(x, y3), linetype = "dashed") +
geom_line(aes(x, y4), linetype = "dashed") +
xlim(0, 5) +
ylim(0, 10) +
labs(title = "Graphical Representation of Constraints",
x = "x",
y = "y") +
theme_minimal()
library(ggplot2)
# Constraints
x <- seq(0, 5, by = 0.1)
y1 <- pmax(10 - 3 * x, 0)  # Adjusted to ensure non-negative values
y2 <- pmax(5 - x, 0)        # Adjusted to ensure non-negative values
y3 <- rep(0, length(x))
y4 <- rep(0, length(x))
df <- data.frame(x, y1, y2, y3, y4)
# Plot
ggplot(df, aes(x, y1)) +
geom_line() +
geom_line(aes(x, y2), color = "red") +
geom_ribbon(data = df, aes(x = x, ymin = pmin(y1, y2), ymax = pmax(y1, y2)), fill = "gray", alpha = 0.3) +
geom_line(aes(x, y3), linetype = "dashed") +
geom_line(aes(x, y4), linetype = "dashed") +
xlim(0, 5) +
ylim(0, 10) +
labs(title = "Graphical Representation of Constraints",
x = "x",
y = "y") +
theme_minimal()
library(lpSolve)
# Coefficients of the objective function (minimize cost)
obj <- c(4, 1)
# Coefficients of the inequality constraints matrix
mat <- matrix(c(3, 1, 1, 1, 0, 0), ncol = 2, byrow = TRUE)
# Right-hand side of the inequality constraints
rhs <- c(10, 5, 3)
# Solve the linear programming problem
result <- lp("min", obj, mat, ">=", rhs)
# Print the results
cat("Number of hours of running process 1:", result$solution[1], "\n")
cat("Number of hours of running process 2:", result$solution[2], "\n")
cat("Optimum cost:", result$objval, "\n")
library(lpSolve)
# Transportation cost per car
cost_matrix <- matrix(c(80, 215, 100, 108, 102, 68), nrow = 3, byrow = TRUE)
# Plant capacities
plant_capacities <- c(1000, 1500, 1200)
# Demand at distribution centers
demand_vector <- c(2300, 1400)
# Solve the transportation problem
result <- lp.transport(cost_matrix, "min", row.signs = "<=", row.rhs = plant_capacities, col.signs = "=", col.rhs = demand_vector)
# Extract the solution
solution_matrix <- matrix(result$solution, nrow = 3, byrow = TRUE)
# Print the optimal solution
cat("Optimal Solution:\n")
print(solution_matrix)
# Print the total transportation cost
cat("Total Transportation Cost: $", result$objval, "\n")
library(lpSolve)
# Transportation cost per car
cost_matrix <- matrix(c(80, 215, 100, 108, 102, 68), nrow = 3, byrow = TRUE)
# Plant capacities
plant_capacities <- c(1000, 1500, 1200)
# Demand at distribution centers
demand_vector <- c(2300, 1400)
# Solve the transportation problem
result <- lp.transport(cost_matrix, "min", row.signs = rep("<=", 3), row.rhs = plant_capacities, col.signs = rep("=", 2), col.rhs = demand_vector)
# Extract the solution
solution_matrix <- matrix(result$solution, nrow = 3, byrow = TRUE)
# Print the optimal solution
cat("Optimal Solution:\n")
print(solution_matrix)
# Print the total transportation cost
cat("Total Transportation Cost: $", result$objval, "\n")
library(clue)
# Install and load the clue package
install.packages("clue")
library(clue)
# Chore matrix
chore_matrix <- matrix(c(5, 10, 9, 14, 9, 15, 10, 10, 10, 12, 8, 12, 16, 11, 13, 15), nrow = 4, byrow = TRUE)
# Apply the Hungarian algorithm
assignment <- solve_LSAP(chore_matrix)
# Print the optimal assignment
cat("Optimal Assignment:\n")
for (i in 1:length(assignment)) {
cat("Child", i, "gets chore", assignment[i], "\n")
}
